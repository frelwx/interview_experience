

[TOC]



## 一 进程与线程

### 1 进程和线程有什么区别

1. 定义：进程（Process）是系统进行除了CPU时间片外的资源（内存、文件、网络、外设）分配基本单位，线程（Thread）是CPU时间分配和调度的基本单位；线程依赖于进程而存在，一个进程至少有一个线程；
2. 资源：进程有自己的独立地址空间，线程共享所属进程的地址空间；进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；
3. 开销：进程的切换是比线程要昂贵的。原因有两点，第一，虽然进程和线程在切换的时候都需要更改上下文，但是线程的上下文信息内容是比进程少的。第二，进程切换的时候需要切换整个地址空间，导致原来的逻辑地址到物理地址的缓存失效，转换变慢，进而使得程序的运行速度变慢。线程切换的时候不会修改当前的地址空间
4. 通信：进程之间的通信机制比较复杂（比如共享存储、消息传递、管道通信）；线程之间的通信则比较方便，因为他们共享全局变量等数据。
5. 安全：因为进程拥有独立的地址空间，一个进程崩溃后，不会对其它进程产生影响。一个线程死掉基本就等于整个进程死掉。

#### 进程有那些资源

代码段、数据段（全局变量和静态变量）、文件描述符、设备

#### 线程独占哪些资源

1. 线程标识符
2. 寄存器
3. 栈指针（其他线程也可以修改）
4. 优先级
5. 错误返回码：线程可能会产生不同的错误返回码（共享的话可能会被其他线程修改），一个线程的错误返回码不应该被其它线程修改；
6. 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号

#### 线程共享那些资源

1. 代码段：代码区存放的是编译后的可执行机器指令，即任何一个函数都可以放到线程中去执行
2. 数据段:：任何一个线程都可以访问全局变量和静态变量
3. 文件描述符
4. 进程当前目录、进程ID
5. 信号处理器：对收到的信号的处理方式

### 2 进程间通信有那些方式

1. 管道：管道是一种特殊的文件，是具有固定大小的缓冲区，是一种半双工的通信方式，数据只能单向流动，上游进程往管道中写入数据，下游进程从管道中接收数据，适合传输大量信息。分为

   1. PIPE（匿名管道）：只能用在亲缘进程中
   2. FIFO（命名管道）：任何进程可以根据管道的文件名将其打开和读写

2. 消息队列：消息队列是保存在内核中的链表，由一个个独立的数据块组成，消息的接收方和发送方要约定具体的消息类型。当进程从消息队列中读取了相关数据块，则内核会将该数据块删除。跟管道相比，消息队列不一定按照先进先出的方式读取，也可以按照消息类型进行兑取。

   消息队列的生命周期与内核相关，如果不显示的删除消息队列，则消息队列会一直存在

   消息队列这种通信方式，跟收发邮件类似。两个进程你来我往的进行沟通

   缺点：不能实现实时通信。数据块是有大小限制的。**消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。

3. 共享内存：共享内存顾名思义，允许两个或多个进程共享同一段物理内存。**不同进程可以将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它**。**共享内存的优点是简单且高效**，访问共享内存区域和访问进程独有的内存区域一样**快**，原因是不需要系统调用，不涉及用户态到内核态的转换，也不需要对数据不必要的复制。**共享内存的缺点是存在并发问题**，有可能出现多个进程修改同一块内存，因此共享内存一般与信号量结合使用。

4. 信号：信号是 Linux 系统响应某些条件而产生的一个事件，由操作系统事先定义，接收到该信号的进程可以采取自定义的行为。这是一种“订阅-发布”的模式。用户进程对信号的处理过程有三种：

   1. 处理信号。定义信号处理函数，当信号发生时，执行相应的处理函数
   2. 忽略信号。当不希望接收到的信号对进程的执行产生影响，而让进程继续执行时，可以忽略该信号，即不对信号进程作任何处理
   3. 不处理也不忽略。执行默认操作，linux 对每种信号都规定了默认操作

5. 套接字Socket：

   1. 不同的计算机的进程之间通过 socket 通信，*也可用于同一台计算机的不同进程*
   2. 需要通信的进程之间首先要各自创建一个 socket，**内容包括主机地址与端口号**，声明自己接收来自某端口地址的数据
   3. 进程通过 socket 把消息发送到网络层中，网络层通过主机地址将其发到目的主机，目的主机通过端口号发给对应进程

6. 信号量(Semaphore)：初始化操作、P操作、V操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态

### 3 进程同步、互斥

同步：先后关系

互斥：多个进程在同一时刻只有一个进程能进入临界区

#### 临界区

进程中对临界资源（互斥资源/共享变量，一次只能给一个进程使用）进行操作的程序片段

#### 互斥锁、信号量

1. 互斥锁：进入临界区后上锁，退出时解锁
2. 信号量：可以解决互斥同步问题，表示某种资源的可用数量。有P、V两种操作

#### 管程

把对共享资源的操作封装成类。每次只允许一个进程访问管程

#### 经典问题

生产者消费者问题

哲学家就餐问题

读者写者问题

#### 并发、异步

并发：多线程操作

异步：CPU给线程分配的时间用完，线程挂起，不占用控制器资源，等到运算器完成后进行回调，确保线程资源有效利用。



### 4 进程有哪几种状态

创建态：创建进程时，所需资源无法满足。

就绪态：进程已获得除处理机以外的所需资源，等待分配处理机资源

运行态：占用处理机资源运行，处于此状态的进程数小于等于CPU数

阻塞态：进程等待某种资源，在资源满足之前无法执行

### 5 进程调度策略有那些

#### 1 早期批处理系统

##### 先来先服务 first-come first-serverd（FCFS）

按照请求的顺序进行调度。非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）；

##### 最短作业优先 shortest job first（SJF）

按估计运行时间最短的顺序进行调度。非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题；

对短进程提供好的响应时间，对长进程不利。

##### 最短剩余时间优先 shortest remaining time next（SRTN）

按剩余运行时间的顺序进行调度。(最短作业优先的抢占式版本)。吞吐量高，开销可能较大，提供好的响应时间；

##### 最高响应比优先 Highest Response Ratio Next（HRRN）

响应比 = 1+ 等待时间/处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。

![image-20221003200131373](C:\Users\lwx\AppData\Roaming\Typora\typora-user-images\image-20221003200131373.png)

##### 优先级反转

高优先级任务被低优先级任务阻塞，导致高优先级任务迟迟得不到调度。但其他中等优先级的任务却能抢到CPU资源。-- 从现象上来看，好像是中优先级的任务比高优先级任务具有更高的优先权。

解决办法1：优先级继承，让低优先级线程在获得同步资源的时候(如果有高优先级的线程也需要使用该同步资源时)，**临时**提升其优先级。让其能更快的执行并释放同步资源。释放同步资源后再恢复其原来的优先级。

解决办法2：优先级天花板，当线程申请某共享资源时，把该线程的优先级提升到可访问这个资源的所有线程中的最高优先级

#### 2 交互式系统

##### 时间片轮转算法：

将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间；若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。

##### 优先级调度算法：

为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

##### 多级反馈队列调度算法：

设置多个就绪队列1、2、3...，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。

抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。

![image-20221003200151491](C:\Users\lwx\AppData\Roaming\Typora\typora-user-images\image-20221003200151491.png)

### 6 什么是僵尸进程

一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁， 而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit，它的作用是 使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集。

一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。

危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。

以下情况不会产生僵尸进程：

- 该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。
- 父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入`WNOHANG`(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。
- 子进程结束时，系统会产生`SIGCHLD`(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；
- 如果[父进程](https://baike.baidu.com/item/父进程?fromModule=lemma_inlink)不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN） 通知[内核](https://baike.baidu.com/item/内核?fromModule=lemma_inlink)，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。

### 什么是孤儿进程？

### 7 线程同步方式有那些

### 8 什么是协程

### 9 进程的异常控制流：陷进、中断、异常和信号

### 10 什么是IO多路复用？怎么实现？

### 11 什么是用户态和内核态

## 二 死锁



## 三 内存管理



## 四 磁盘调度



