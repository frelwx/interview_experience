## 传输层

### TCP三次握手

![三次握手](https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191129101827556_21212.png)

客户端两个状态：syn-sent、established

服务器三个状态：listen某个端口、syn-rcvd、established

1. 第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；
2. 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；
3. 第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。

##### TCP建立连接可以两次握手吗？

**从整体通信双方的角度来看：**TCP是一个全双工的通信方式，通信双方都需要确认自己的发送机、接收机是正常的。假如只有两次握手，那么server无法知道自己发送的同步请求是否被client正确接收。此时对于client来说，他能确认自己的发送机、接收机是没问题的，可以正常通信；但是server只能确认自己的接收机是正常工作的，不能确认发送机是正常的。这意味着server在收到来自client的确认之前是没办法发送消息的。

**从更细致的角度来看：**首先是为了防止某个旧的连接请求造成server端错误地建立连接，比如说，当网络比较糟糕的时候，client的一个旧的同步请求报文比新的请求先到达，那么当server发送完确认和请求同步报文后，也就是两次握手后，server就认为自己可以建立连接，开始发送数据。但其实对于client来说，是没有建立起连接的，他会发送一个RST复位报文段要求对方重新建立连接。再回到server这边，server因为草率地建立起连接，而白白地浪费了系统资源。

##### 可以采用四次握手吗？

可以，但没必要。中间的两次可以合并成一次。

##### 第三次握手中，如果客户端的ACK未送达服务器，会怎样？

server会重新发送SYN+ACK报文段（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。

client此时已经建立了连接，可以向server发送数据。分两种情况：如果此时server因为长时间没收到确认而关闭连接，client向server发送数据，server会以RST报文应答，要求重新建立连接；如果server还没关闭连接，那就根据确认号判断是否是client发送的应答，如果是，则建立连接，否则TCP冗余确认的机制请求client重传。

##### 如果已经建立了连接，但客户端出现了故障怎么办？

心跳机制：服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### TCP四次挥手

![四次挥手](https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191129112652915_15481.png)

- 第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；
- 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。
- 第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；
- 第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。

##### 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。

##### 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？

客户端没有收到ACK确认，会重新发送FIN请求。

##### 客户端TIME_WAIT状态的意义是什么？为什么是2分钟？

第四次挥手时，客户端发送给服务器的ACK有可能丢失，如果Server没有收到ACK，就会重发FIN。如果不等待的话，Server会因为没有收到ACK而不断重发FIN。

MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

### TCP流量控制

![20191129145400104_2106](C:\Users\lwx\Desktop\20191129145400104_2106.png)

这里的窗口是接收窗口rwnd(receive window)，此外还有一个拥塞窗口cwnd（congestion window），发送窗口swnd(send window) = min(rwnd, cwnd)

#### 什么是零窗口（接收窗口为0时会怎样）？

如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

### TCP拥塞控制

![拥塞控制](https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191129153624025_28293.png)

拥塞控制主要由四个算法组成：**慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）**

**慢启动：**刚建立连接是，cwnd = 1（MSS，maximum segment size），每收到一个确认，就令cwnd += 1。因此cwnd会随RTT(传输轮次)呈指数增长。

**拥塞避免：**当cwnd到达与之ssthresh后，改成线性增长。

无论在慢启动还是拥塞避免的阶段，只要网络发生了拥塞（未按时收到确认），就把ssthresh减半，但不能小于2mss，即ssthresh = max(ssthresh/ 2, 2MSS)。然后执行慢开始（这是没有使用快重传的情况）

**快重传：**当发送方连续收到3个重复的ACK，则直接重传对方未收到的报文段，而不必等待那个报文段的重传计时器。

**快恢复：**在快重传后，把ssthresh减小为原来的一半，但是不进入慢开始阶段，而是进入拥塞避免状态。这是因为发送方认为网络拥塞状况不是很严重，否则就不会收到三个连续的ACK

### TCP如何最大利用带宽？

TCP速率受到三个因素影响：窗口、带宽（单位时间内从发送端到接收端所能通过的“最高数据率”，是一种硬件限制）、RTT（TCP根据得到的RTT值更新RTO值，即Retransmission TimeOut，就是重传间隔，发送端对每个发出的数据包进行计时，如果在RTO时间内没有收到所发出的数据包的对应ACK，则任务数据包丢失，将重传数据）

### TCP与UDP的区别

1. TCP是面向连接的，TDP是无连接的
2. TCP是可靠的，UDP是不可靠的
3. TCP支持点对点，UDP支持多对多
4. TCP是面向字节的，UDP是面向报文的。面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。
5. TCP有拥塞控制机制，UDP没有。
6. TCP首部开销（20字节）比UDP首部开销（8字节）要大
7. UDP 的主机不需要维持复杂的连接状态表

#### HTTP可以使用UDP吗？

HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠

**http 3.0 使用udp实现** https://zh.wikipedia.org/wiki/HTTP/3

### TCP如何保证传输的可靠性

1. 数据包校验
2. 对失序数据包重新排序（TCP报文具有序列号）
3. 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；
4. 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；
5. 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出
6. 丢弃重复数据

1. 

## 应用层

### HTTP和HTTPS有什么区别？

1. 端口不同：HTTP使用的是80端口，HTTPS使用443端口；
2. HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；
3. HTTPS由于加密解密会带来更大的CPU和内存开销；
4. HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买

### GET与POST的区别？

1. GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；
2. GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；
3. 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；
4. 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；
5. GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；
6. GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制

### Session与Cookie的区别？

Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案

Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。

### 从输入网址到获得页面的过程 (越详细越好)？

1. 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；
2. 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；
3. TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；
4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；
5. 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；
6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

### HTTP请求有哪些常见状态码？

1. 2xx状态码：操作成功。200 OK
2. 3xx状态码：重定向。301 永久重定向；302暂时重定向
3. 4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；
4. 5xx状态码：服务端错误。500服务器内部错误；501服务不可用

### 什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？

每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。

### 应用层常见协议

- FTP(21端口)：文件传输协议
- SSH(22端口)：远程登陆
- TELNET(23端口)：远程登录
- SMTP(25端口)：发送邮件
- POP3(110端口)：接收邮件
- HTTP(80端口)：超文本传输协议
- DNS(53端口)：运行在UDP上，域名解析服务

### TCP（HTTP）长链接和短连接的区别

HTTP 的长连接和短连接本质上是 TCP 长连接和短连接

tcp短链接

客户端和服务器之间的TCP链接只能为一个HTTP请求服务，当服务器处理完客户的一次HTTP请求之后就会主动将TCP连接关闭。此后如果客户与同一个服务器进行多次HTTP请求的话还需要重新建立TCP连接。也就是说客户的多次HTTP请求不能共用一个TCP连接。

tcp长连接

client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。多次HTTP请求共用同一个TCP连接。

## 计算机网络体系结构



![计算机网络体系结构](https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191129195451183_16713.png)

### 路由器、交换机位于哪一层？

- 路由器网络层，根据IP地址进行寻址；
- 交换机数据链路层，根据MAC地址进行寻址

## 网络层

### 常见协议

IP、ARP、NAT、RIP...，IP 协议主要解决网络路由和寻址问题

### 什么是ARP协议 (Address Resolution Protocol)？

**ARP协议完成了IP地址与物理地址的映射**。每一个主机都设有一个 ARP 高速缓存，里面有**所在的局域网**上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向**所在的局域网**发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。

如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。

### IP地址的分类

路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。

<img src="https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191201085151639_2895.png" alt="IP address" style="zoom:50%;" />

### 什么叫划分子网？

从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。

### 什么是NAT (Network Address Translation, 网络地址转换)？

用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。





